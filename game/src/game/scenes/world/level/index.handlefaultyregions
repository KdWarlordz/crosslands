import { WorldGenerator } from 'gen-biome'
import Phaser from 'phaser'
import { v4 as uuidv4 } from 'uuid'

import { GameEvent, GameSettings } from '../../../types'

import {
  LEVEL_MAP_TILE,
  LEVEL_MAP_SIZE,
  LEVEL_MAP_MAX_HEIGHT,
  LEVEL_BIOME_PARAMETERS,
  LEVEL_SCENERY_TILE,
  LEVEL_PLANETS,
  LEVEL_SEED_SIZE,
  LEVEL_MAP_PERSPECTIVE
} from './const'
import { TileMatrix } from './tile-matrix'
import {
  LevelPlanet,
  LevelSceneryTexture,
  LevelTilesetTexture,
  SpawnTarget,
  TileType,
  BiomeType
} from './types'

import type { ITile } from './tile-matrix/types'
import type {
  ILevel,
  LevelBiome,
  LevelData,
  LevelSavePayload,
  PositionAtMatrix,
  PositionAtWorld,
  TilePosition
} from './types'
import type { Effect } from '../fx-manager/effect'
import type { IWorld } from '../types'
import type { World } from 'gen-biome'
import type { INavigator } from '~lib/navigator/types'

import { Assets } from '~lib/assets'
import { addWorld } from '~lib/client/api'
import { isPositionsEqual } from '~lib/dimension'
import { Navigator } from '~lib/navigator'

Assets.RegisterSprites(LevelTilesetTexture, LEVEL_MAP_TILE)
Assets.RegisterSprites(LevelSceneryTexture, LEVEL_SCENERY_TILE)

const storageKey = 'map'

export class Level extends TileMatrix implements ILevel {
  readonly scene: IWorld

  readonly navigator: INavigator

  readonly map: World<LevelBiome>

  readonly planet: LevelPlanet

  readonly gridCollide: boolean[][] = []

  readonly gridSolid: boolean[][] = []

  private _effectsOnGround: Effect[] = []

  public get effectsOnGround() {
    return this._effectsOnGround
  }

  private set effectsOnGround(v) {
    this._effectsOnGround = v
  }

  private _groundLayer: Phaser.Tilemaps.TilemapLayer

  public get groundLayer() {
    return this._groundLayer
  }

  private set groundLayer(v) {
    this._groundLayer = v
  }

  private sceneryTiles: Phaser.GameObjects.Group

  private selectionRectangle: Phaser.GameObjects.Graphics

  private selectedTiles: PositionAtMatrix[] = []
  private hasInvalidTiles: boolean = false

  private isSelecting: boolean = false // To track if the mouse is being held down
  private lastSelectedTile: PositionAtMatrix | null = null // To track the last selected tile

  private tileCountText: Phaser.GameObjects.Text
  private tileCountTexts: Phaser.GameObjects.Text[] = []

  private showCount: boolean = true

  constructor(scene: IWorld, { planet, seed, showCount = true }: LevelData) {
    super(LEVEL_MAP_SIZE, LEVEL_MAP_MAX_HEIGHT)

    this.scene = scene
    this.planet = planet ?? LevelPlanet.EARTH

    this.map = this.loadMap(seed)

    this.gridCollide = this.map.getMatrix().map((y) => y.map((x) => x.collide))
    this.gridSolid = this.map.getMatrix().map((y) => y.map((x) => !x.solid))

    this.navigator = new Navigator()

    this.addTilemap()
    this.addMapTiles()
    this.addScenery()

    this.addInteractiveArea()
    this.createSelectionRectangle()

    this.showCount = showCount

    this.scene.input.on('pointermove', (pointer: Phaser.Input.Pointer) => {
      if (this.isSelecting && pointer.leftButtonDown()) {
        this.handleTileSelection(pointer.worldX, pointer.worldY, false)
      }
    })

    this.scene.input.on('pointerup', (pointer: Phaser.Input.Pointer) => {
      if (pointer.leftButtonReleased()) {
        this.isSelecting = false
        this.lastSelectedTile = null // Reset last selected tile on mouse up
      }
    })

    this.scene.game.events.on(
      `${GameEvent.UPDATE_SETTINGS}.${GameSettings.EFFECTS}`,
      (value: string) => {
        if (value === 'off') {
          this.removeEffects()
        }
      }
    )
  }

  public loadMap(seed?: number[]): World<LevelBiome> {
    try {
      const stringValue = localStorage.getItem(storageKey)
      if (stringValue) {
        const data = JSON.parse(stringValue)
        if (
          !data.matrix ||
          !Array.isArray(data.matrix) ||
          data.matrix.length === 0 ||
          !data.seed ||
          !Array.isArray(data.seed)
        ) {
          throw new Error('Invalid local map(s) data')
        }

        const generator = new WorldGenerator<LevelBiome>({
          width: data.matrix.length,
          height: data.matrix[0].length
        })

        this.initializeBiomes(generator)

        const world = generator.generate({
          seed: data.seed,
          seedSize: LEVEL_SEED_SIZE
        })

        for (let y = 0; y < data.matrix.length; y++) {
          for (let x = 0; x < data.matrix[y].length; x++) {
            world.replaceAt({ x, y }, data.matrix[y][x])
          }
        }

        console.log('World successfully loaded and matrix replaced')
        return world
      } else {
        console.log('No map(s) data found locally storage, generating new map')
        return this.generateNewMap(seed)
      }
    } catch (error) {
      console.error('Error reading from locap map(s)', error)
      return this.generateNewMap(seed)
    }
  }

  private initializeBiomes(generator: WorldGenerator<LevelBiome>) {
    generator.clearLayers()
    const layer = generator.addLayer(LEVEL_BIOME_PARAMETERS)
    LEVEL_PLANETS[this.planet].BIOMES.forEach((biome) => {
      if (biome.params) {
        layer.addBiome(biome.params, biome.data)
      }
    })
  }

  private generateNewMap(seed?: number[]): World<LevelBiome> {
    const generator = new WorldGenerator<LevelBiome>({
      width: LEVEL_MAP_SIZE,
      height: LEVEL_MAP_SIZE
    })

    this.initializeBiomes(generator)

    const map = generator.generate({
      seed,
      seedSize: LEVEL_SEED_SIZE
    })

    // console.log('Storing newly generated map')
    // addWorld({
    //   chain: 'kadena',
    //   planet: 'earth',
    //   id: uuidv4(),
    //   seed: map.seed,
    //   matrix: map.getMatrix()
    // })
    return map
  }

  public looseEffects() {
    this.effectsOnGround.forEach((effect) => {
      effect.setAlpha(effect.alpha - 0.2)
      if (effect.alpha <= 0) {
        effect.destroy()
      }
    })
  }

  private removeEffects() {
    this.effectsOnGround.forEach((effect) => {
      effect.destroy()
    })
    this.effectsOnGround = []
  }

  public readSpawnPositions(target: SpawnTarget, grid: number = 2) {
    const positions: PositionAtMatrix[] = []

    for (let sX = grid; sX < this.map.width - grid; sX += grid) {
      for (let sY = grid; sY < this.map.height - grid; sY += grid) {
        const position = {
          x: sX + Phaser.Math.Between(-1, 1),
          y: sY + Phaser.Math.Between(-1, 1),
          z: 1
        }
        const targets = this.map.getAt(position)?.spawn

        if (targets && targets.includes(target)) {
          positions.push(position)
        }
      }
    }

    return positions
  }

  public hasTilesBetweenPositions(
    positionA: PositionAtWorld,
    positionB: PositionAtWorld
  ) {
    const positionAtMatrixA = Level.ToMatrixPosition(positionA)
    const positionAtMatrixB = Level.ToMatrixPosition(positionB)
    const current: TilePosition = { ...positionAtMatrixA, z: 1 }
    const dx = Math.abs(positionAtMatrixB.x - positionAtMatrixA.x)
    const dy = Math.abs(positionAtMatrixB.y - positionAtMatrixA.y)
    let err = dx - dy

    while (!isPositionsEqual(current, positionAtMatrixB)) {
      const shift = 2 * err

      if (shift > -dy) {
        err -= dy
        current.x += positionAtMatrixA.x < positionAtMatrixB.x ? 1 : -1
      }
      if (shift < dx) {
        err += dx
        current.y += positionAtMatrixA.y < positionAtMatrixB.y ? 1 : -1
      }

      if (this.getTile(current)?.tileType === TileType.MAP) {
        return true
      }
    }

    return false
  }

  public getBiome(type: BiomeType): Nullable<LevelBiome> {
    return (
      LEVEL_PLANETS[this.planet].BIOMES.find(
        (biome) => biome.data.type === type
      )?.data ?? null
    )
  }

  public getFreeAdjacentTiles(position: PositionAtMatrix) {
    const positions: PositionAtMatrix[] = [
      { x: position.x + 1, y: position.y },
      { x: position.x, y: position.y + 1 },
      { x: position.x - 1, y: position.y },
      { x: position.x, y: position.y - 1 },
      { x: position.x + 1, y: position.y - 1 },
      { x: position.x + 1, y: position.y + 1 },
      { x: position.x - 1, y: position.y + 1 },
      { x: position.x - 1, y: position.y - 1 }
    ]

    return positions.filter((point) => this.isFreePoint({ ...point, z: 1 }))
  }

  private isInvalidTile(tile: PositionAtMatrix): boolean {
    const biome = this.map.getAt(tile)?.type
    return (
      biome === BiomeType.WATER ||
      biome === BiomeType.MOUNT ||
      biome === BiomeType.SNOW
    )
  }

  private confirmSelection() {
    console.log('Confirmed selection:', this.selectedTiles)
    // Implement additional logic for confirmed selection here
  }

  private addTilemap() {
    const data = new Phaser.Tilemaps.MapData({
      width: LEVEL_MAP_SIZE,
      height: LEVEL_MAP_SIZE,
      tileWidth: LEVEL_MAP_TILE.width,
      tileHeight: LEVEL_MAP_TILE.height * 0.5,
      orientation: Phaser.Tilemaps.Orientation.ISOMETRIC,
      format: Phaser.Tilemaps.Formats.ARRAY_2D
    })

    const tilemap = new Phaser.Tilemaps.Tilemap(this.scene, data)
    const tileset = tilemap.addTilesetImage(
      LevelTilesetTexture[this.planet],
      undefined,
      LEVEL_MAP_TILE.width,
      LEVEL_MAP_TILE.height,
      LEVEL_MAP_TILE.margin,
      LEVEL_MAP_TILE.spacing
    )

    if (!tileset) {
      throw Error('Unable to create map tileset')
    }

    this.addFalloffLayer(tilemap, tileset)
    this.addGroundLayer(tilemap, tileset)
  }

  private addGroundLayer(
    tilemap: Phaser.Tilemaps.Tilemap,
    tileset: Phaser.Tilemaps.Tileset
  ) {
    const layer = tilemap.createBlankLayer(
      'ground',
      tileset,
      -LEVEL_MAP_TILE.width * 0.5,
      -LEVEL_MAP_TILE.height * 0.25
    )

    if (!layer) {
      throw Error('Unable to create map layer')
    }

    this.groundLayer = layer
  }

  private addFalloffLayer(
    tilemap: Phaser.Tilemaps.Tilemap,
    tileset: Phaser.Tilemaps.Tileset
  ) {
    const tileAngle = Math.atan2(1 / LEVEL_MAP_PERSPECTIVE, 1)
    const visibleDiagonal =
      this.scene.game.canvas.clientWidth / 2 / Math.sin(tileAngle)
    const edgeSize = Math.ceil(visibleDiagonal / LEVEL_MAP_TILE.edgeLength)
    const sizeInTiles = edgeSize * 2 + LEVEL_MAP_SIZE
    const position = Level.ToWorldPosition({ x: -edgeSize, y: -edgeSize }, 0)

    const layer = tilemap.createBlankLayer(
      'falloff',
      tileset,
      position.x - LEVEL_MAP_TILE.width * 0.5,
      position.y - LEVEL_MAP_TILE.height * LEVEL_MAP_TILE.origin,
      sizeInTiles,
      sizeInTiles
    )

    if (!layer) {
      return
    }

    const biome = LEVEL_PLANETS[this.planet].BIOMES[0].data
    const index = Array.isArray(biome.tileIndex)
      ? biome.tileIndex[0]
      : biome.tileIndex

    for (let y = 0; y < sizeInTiles; y++) {
      for (let x = 0; x < sizeInTiles; x++) {
        if (
          x < edgeSize ||
          x >= sizeInTiles - edgeSize ||
          y < edgeSize ||
          y >= sizeInTiles - edgeSize
        ) {
          layer.putTileAt(index, x, y, false)
        }
      }
    }
  }

  private addMapTiles() {
    const addTile = (position: PositionAtMatrix, biome: LevelBiome) => {
      const index = Array.isArray(biome.tileIndex)
        ? Phaser.Math.Between(...biome.tileIndex)
        : biome.tileIndex

      if (biome.z === 0) {
        // Add tile to static tilemap layer
        this.groundLayer.putTileAt(index, position.x, position.y, false)
      } else {
        // Add tile as image
        // Need for correct calculate depth
        this.addMountTile(index, position, biome.z)
      }
    }

    this.map.each((position, biome) => {
      addTile(position, biome)

      // Add tile to hole
      if (biome.z > 1) {
        const z = biome.z - 1
        const shiftX = this.map.getAt({ x: position.x + 1, y: position.y })
        const shiftY = this.map.getAt({ x: position.x, y: position.y + 1 })

        if ((shiftX && shiftX.z !== z) || (shiftY && shiftY.z !== z)) {
          const patch = LEVEL_PLANETS[this.planet].BIOMES.find(
            (b) => b.data.z === z
          )

          if (patch) {
            addTile(position, patch.data)
          }
        }
      }
    })
  }

  private addMountTile(index: number, position: PositionAtMatrix, z: number) {
    const positionAtWorld = Level.ToWorldPosition(position, z)
    const depth = positionAtWorld.y + (z - 1) * LEVEL_MAP_TILE.height
    const tile = this.scene.add.image(
      positionAtWorld.x,
      positionAtWorld.y,
      LevelTilesetTexture[this.planet],
      index
    ) as ITile

    tile.tileType = TileType.MAP

    tile.setDepth(depth)
    tile.setOrigin(0.5, LEVEL_MAP_TILE.origin)
    this.putTile(tile, { ...position, z }, false)
  }

  private addScenery() {
    this.sceneryTiles = this.scene.add.group()

    const positions = this.readSpawnPositions(SpawnTarget.SCENERY)
    const count = Math.ceil(
      LEVEL_MAP_SIZE * LEVEL_PLANETS[this.planet].SCENERY_DENSITY
    )

    for (let i = 0; i < count; i++) {
      const positionAtMatrix = Phaser.Utils.Array.GetRandom(positions)
      const tilePosition: TilePosition = { ...positionAtMatrix, z: 1 }

      if (this.isFreePoint(tilePosition)) {
        const positionAtWorld = Level.ToWorldPosition(positionAtMatrix)
        const tile = this.scene.add.image(
          positionAtWorld.x,
          positionAtWorld.y,
          LevelSceneryTexture[this.planet],
          Phaser.Math.Between(
            0,
            LEVEL_PLANETS[this.planet].SCENERY_VARIANTS_COUNT - 1
          )
        ) as ITile

        tile.tileType = TileType.SCENERY
        tile.clearable = true

        tile.setDepth(positionAtWorld.y)
        tile.setOrigin(0.5, LEVEL_SCENERY_TILE.origin)
        this.putTile(tile, tilePosition)
        this.sceneryTiles.add(tile)
      }
    }
  }

  private addInteractiveArea() {
    const interactiveArea = this.scene.add
      .zone(
        this.scene.cameras.main.centerX,
        this.scene.cameras.main.centerY,
        LEVEL_MAP_SIZE * LEVEL_MAP_TILE.width,
        LEVEL_MAP_SIZE * LEVEL_MAP_TILE.height
      )
      .setOrigin(0.5)

    interactiveArea.setInteractive({ useHandCursor: true })

    interactiveArea.on('pointerdown', (pointer: Phaser.Input.Pointer) => {
      if (pointer.rightButtonDown()) {
        this.deselectAllTiles()
      } else if (pointer.leftButtonDown()) {
        this.isSelecting = true
        this.handleTileSelection(pointer.worldX, pointer.worldY, true)
      }
    })
  }

  private createSelectionRectangle() {
    this.selectionRectangle = this.scene.add.graphics()
    this.selectionRectangle.lineStyle(2, 0x00ff00, 1)
    this.selectionRectangle.fillStyle(0x00ff00, 0.4) // Set opacity to 0.6

    // Add this line to create the text object
    this.tileCountText = this.scene.add
      .text(0, 0, '', {
        font: '12px Arial',
        color: '#ffffff'
      })
      .setOrigin(0.5)
  }

  private getSelectionColor(width: number, height: number): number {
    if (width === 4 && height === 4) {
      return 0xffff00 // Yellow
    } else if (width === 4 && height === 8) {
      return 0xffa500 // Orange
    } else if (width === 8 && height === 8) {
      return 0x0000ff // Blue
    } else {
      return 0x00ff00 // Default green for other sizes
    }
  }

  private handleTileSelection(
    worldX: number,
    worldY: number,
    isPointerDown: boolean
  ) {
    const clickedTile = Level.ToMatrixPosition({ x: worldX, y: worldY })

    if (
      this.lastSelectedTile &&
      clickedTile.x === this.lastSelectedTile.x &&
      clickedTile.y === this.lastSelectedTile.y
    ) {
      return
    }

    if (isPointerDown) {
      const tileIndex = this.selectedTiles.findIndex(
        (tile) => tile.x === clickedTile.x && tile.y === clickedTile.y
      )

      if (tileIndex >= 0) {
        this.selectedTiles.splice(tileIndex, 1)
      } else {
        if (this.selectedTiles.length < 64) {
          this.selectedTiles.push(clickedTile)
        } else {
          console.log('Maximum selection limit reached')
        }
      }

      this.lastSelectedTile = clickedTile
    } else {
      if (
        !this.selectedTiles.some(
          (tile) => tile.x === clickedTile.x && tile.y === clickedTile.y
        )
      ) {
        if (this.selectedTiles.length < 64) {
          this.selectedTiles.push(clickedTile)
        } else {
          console.log('Maximum selection limit reached')
        }
        this.lastSelectedTile = clickedTile
      }
    }

    this.hasInvalidTiles = this.selectedTiles.some((tile) =>
      this.isInvalidTile(tile)
    )

    this.drawSelectionRectangle(this.selectedTiles)

    if (this.hasInvalidTiles) {
      setTimeout(() => {
        this.selectedTiles = this.selectedTiles.filter(
          (tile) => !this.isInvalidTile(tile)
        )
        this.drawSelectionRectangle(this.selectedTiles)
        console.log('Invalid tiles deselected:', this.selectedTiles)
      }, 500)
    } else if (isPointerDown) {
      this.confirmSelection()
    }
  }

  private drawSelectionRectangle(tiles: PositionAtMatrix[]) {
    this.selectionRectangle.clear()
    this.tileCountTexts.forEach((text) => text.destroy())
    this.tileCountTexts = []

    const floodFill = (
      startTile: PositionAtMatrix,
      tileSet: Set<string>,
      visited: Set<string>
    ): PositionAtMatrix[] => {
      const stack = [startTile]
      const region = []

      while (stack.length > 0) {
        const { x, y } = stack.pop()!
        const key = `${x},${y}`

        if (!visited.has(key) && tileSet.has(key)) {
          visited.add(key)
          region.push({ x, y })

          stack.push({ x: x + 1, y })
          stack.push({ x: x - 1, y })
          stack.push({ x, y: y + 1 })
          stack.push({ x, y: y - 1 })
          stack.push({ x: x + 1, y: y + 1 })
          stack.push({ x: x - 1, y: y - 1 })
          stack.push({ x: x + 1, y: y - 1 })
          stack.push({ x: x - 1, y: y + 1 })
        }
      }

      return region
    }

    const tileSet = new Set(tiles.map((tile) => `${tile.x},${tile.y}`))
    const visited = new Set<string>()
    const regions: PositionAtMatrix[][] = []

    tiles.forEach((tile) => {
      const key = `${tile.x},${tile.y}`
      if (!visited.has(key)) {
        const region = floodFill(tile, tileSet, visited)
        regions.push(region)
      }
    })

    const getColorForTiles = (numTiles: number) => {
      if (numTiles === 64) {
        return 0x0000ff
      } else if (numTiles === 32) {
        return 0xffa500
      } else if (numTiles === 16) {
        return 0xffff00
      }
      return 0x00ff00
    }

    const isValidRegion = (region: PositionAtMatrix[]) => {
      const length = region.length
      return length === 16 || length === 32 || length === 64
    }

    regions.forEach((region) => {
      const regionSize = region.length
      const color = getColorForTiles(regionSize)
      const isValid = isValidRegion(region)

      const sortedTiles = region.slice().sort((a, b) => a.x - b.x || a.y - b.y)

      sortedTiles.forEach((tile, index) => {
        const worldPos = Level.ToWorldPosition(tile)
        const isoWidth = LEVEL_MAP_TILE.width * 0.5
        const isoHeight = LEVEL_MAP_TILE.height * 0.25

        const isInvalid = this.isInvalidTile(tile) || !isValid
        this.selectionRectangle.fillStyle(isInvalid ? 0xff0000 : color, 0.6)

        this.selectionRectangle.beginPath()
        this.selectionRectangle.moveTo(worldPos.x, worldPos.y - isoHeight)
        this.selectionRectangle.lineTo(worldPos.x + isoWidth, worldPos.y)
        this.selectionRectangle.lineTo(worldPos.x, worldPos.y + isoHeight)
        this.selectionRectangle.lineTo(worldPos.x - isoWidth, worldPos.y)
        this.selectionRectangle.closePath()
        this.selectionRectangle.fillPath()

        if (this.showCount && isValid) {
          const tileCountText = this.scene.add
            .text(worldPos.x, worldPos.y, (index + 1).toString(), {
              font: '12px Arial',
              color: '#ffffff'
            })
            .setOrigin(0.5)

          this.tileCountTexts.push(tileCountText)
        }
      })
    })

    this.tileCountText.setVisible(false)
  }

  private deselectAllTiles() {
    this.selectedTiles = []
    this.selectionRectangle.clear()
    this.tileCountTexts.forEach((text) => text.destroy())
    this.tileCountTexts = []
  }

  public getSavePayload(): LevelSavePayload {
    return {
      planet: this.planet,
      seed: this.map.seed
    }
  }

  static ToMatrixPosition(position: PositionAtWorld): PositionAtMatrix {
    const { width, height } = LEVEL_MAP_TILE
    const n = {
      x: position.x / (width * 0.5),
      y: position.y / (height * 0.25)
    }

    return {
      x: Math.round((n.x + n.y) / 2),
      y: Math.round((n.y - n.x) / 2)
    }
  }

  static ToWorldPosition(
    position: PositionAtMatrix,
    z: number = 1
  ): PositionAtWorld {
    const { width, height } = LEVEL_MAP_TILE

    return {
      x: (position.x - position.y) * (width * 0.5),
      y: (position.x + position.y) * (height * 0.25) - (z - 1) * (height * 0.5)
    }
  }
}
